{
    "docs": [
        {
            "location": "/",
            "text": "Welcome to MkDocs\n\u00b6\n\n\nFor full documentation visit \nmkdocs.org\n.\n\n\nblah...\n\n\nCommands\n\u00b6\n\n\n\n\nmkdocs new [dir-name]\n - Create a new project.\n\n\nmkdocs serve\n - Start the live-reloading docs server.\n\n\nmkdocs build\n - Build the documentation site.\n\n\nmkdocs help\n - Print this help message.\n\n\n\n\nProject layout\n\u00b6\n\n\n1\n2\n3\n4\nmkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.",
            "title": "Home"
        },
        {
            "location": "/#welcome-to-mkdocs",
            "text": "For full documentation visit  mkdocs.org .  blah...",
            "title": "Welcome to MkDocs"
        },
        {
            "location": "/#commands",
            "text": "mkdocs new [dir-name]  - Create a new project.  mkdocs serve  - Start the live-reloading docs server.  mkdocs build  - Build the documentation site.  mkdocs help  - Print this help message.",
            "title": "Commands"
        },
        {
            "location": "/#project-layout",
            "text": "1\n2\n3\n4 mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.",
            "title": "Project layout"
        },
        {
            "location": "/aspnetcore/",
            "text": "ASP.net Core Web Application\n\u00b6\n\n\nVisual Studio: New Project - ASP.NET CoreWeb Application (.NET Core)\n\n\nProgram.cs\n\u00b6\n\n\nProgram.cs\n contains the \nMain\n method which is the application starting point.\n\n\nThis uses \nWebHostBuilder\n to build a web hosting app using extension methods. The default \nProgram.cs\n file created by the new project template is shown below.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n \npublic\n \nclass\n \nProgram\n\n    \n{\n\n        \npublic\n \nstatic\n \nvoid\n \nMain\n(\nstring\n[]\n \nargs\n)\n\n        \n{\n\n            \nvar\n \nhost\n \n=\n \nnew\n \nWebHostBuilder\n()\n\n                \n.\nUseKestrel\n()\n\n                \n.\nUseContentRoot\n(\nDirectory\n.\nGetCurrentDirectory\n())\n\n                \n.\nUseIISIntegration\n()\n\n                \n.\nUseStartup\n<\nStartup\n>()\n\n                \n.\nUseApplicationInsights\n()\n\n                \n.\nBuild\n();\n\n\n            \nhost\n.\nRun\n();\n\n        \n}\n\n    \n}\n\n\n\n\n\n\n\n.UseKestrel\n()\n - use the Kestrel web server (can change to use others)\n\n\n.UseContentRoot\n(\nDirectory.GetCurrentDirectory\n())\n - tells the server where the root directory for content is\n\n\nUseIISIntegration()\n -\n\n\nUseStartup<Startup>()\n - tells server which class to use for startup configuration (in this case the \nStartup\n class defined in \nStartup.cs\n)\n\n\nUseApplicationInsights()\n -\n\n\nBuild();\n - now go and build us a webserver that we can run with \nhost.Run();\n\n\nStartup.cs\n\u00b6\n\n\nStartup.cs\n defines the request handling pipeline, and must contain the following methods:\n\n\n1\n2\npublic\n \nvoid\n \nConfigureServices\n(\nIServiceCollection\n \nservices\n)\n \n{...}\n\n\npublic\n \nvoid\n \nConfigure\n(\nIApplicationBuilder\n \napp\n)\n \n{...}",
            "title": "Aspnetcore"
        },
        {
            "location": "/aspnetcore/#aspnet-core-web-application",
            "text": "Visual Studio: New Project - ASP.NET CoreWeb Application (.NET Core)",
            "title": "ASP.net Core Web Application"
        },
        {
            "location": "/aspnetcore/#programcs",
            "text": "Program.cs  contains the  Main  method which is the application starting point.  This uses  WebHostBuilder  to build a web hosting app using extension methods. The default  Program.cs  file created by the new project template is shown below.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15   public   class   Program \n     { \n         public   static   void   Main ( string []   args ) \n         { \n             var   host   =   new   WebHostBuilder () \n                 . UseKestrel () \n                 . UseContentRoot ( Directory . GetCurrentDirectory ()) \n                 . UseIISIntegration () \n                 . UseStartup < Startup >() \n                 . UseApplicationInsights () \n                 . Build (); \n\n             host . Run (); \n         } \n     }    .UseKestrel ()  - use the Kestrel web server (can change to use others)  .UseContentRoot ( Directory.GetCurrentDirectory ())  - tells the server where the root directory for content is  UseIISIntegration()  -  UseStartup<Startup>()  - tells server which class to use for startup configuration (in this case the  Startup  class defined in  Startup.cs )  UseApplicationInsights()  -  Build();  - now go and build us a webserver that we can run with  host.Run();",
            "title": "Program.cs"
        },
        {
            "location": "/aspnetcore/#startupcs",
            "text": "Startup.cs  defines the request handling pipeline, and must contain the following methods:  1\n2 public   void   ConfigureServices ( IServiceCollection   services )   {...}  public   void   Configure ( IApplicationBuilder   app )   {...}",
            "title": "Startup.cs"
        },
        {
            "location": "/links/",
            "text": "Useful Links\n\u00b6\n\n\n\n\nMarkdown and MKDocs\n\u00b6\n\n\nGitHub: \nMastering Markdown\n and\n\nBasic writing and formatting syntax\n\nAlso \nMarkdown Cheatsheet\n\n\nMKDocs is a utility to build a static web site out of markdown documents which can then be\nviewed locally or hosted on \nGitHub Pages\n.\n\n\nMKDocs\n\n\nMaterial\n is a theme with added goodies that works well with Markdown.\n\n\nMarkdown requires \nPython\n to be installed on the machine.",
            "title": "Links"
        },
        {
            "location": "/links/#useful-links",
            "text": "",
            "title": "Useful Links"
        },
        {
            "location": "/links/#markdown-and-mkdocs",
            "text": "GitHub:  Mastering Markdown  and Basic writing and formatting syntax \nAlso  Markdown Cheatsheet  MKDocs is a utility to build a static web site out of markdown documents which can then be\nviewed locally or hosted on  GitHub Pages .  MKDocs  Material  is a theme with added goodies that works well with Markdown.  Markdown requires  Python  to be installed on the machine.",
            "title": "Markdown and MKDocs"
        },
        {
            "location": "/programming-concepts/",
            "text": "Programming Concepts\n\u00b6\n\n\n\n\nDependency Injection / Inversion of Control\n\u00b6\n\n\nIntroduction to Dependency Injection in ASP.NET Core\n - Microsoft page\n\n\nWhat and Why?\n\u00b6\n\n\n\n\nA \ndependency\n is another class that the code you are writing depends on.\n\n\n\n\nSay you are writing an app and you want to log certain performance information - maybe you get current weather data from a web service and you want to log how long each request takes. You write a class to do that logging and call it \nLogger\n with a \nLog(string message)\n method which writes your message to a file.\n\n\n1\n2\n3\n4\n5\n6\n7\npublic\n \nclass\n \nLogger\n\n\n{\n\n    \npublic\n \nvoid\n \nLog\n(\nstring\n \nmessage\n)\n\n    \n{\n\n        \n// write message to log file\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nHere is the class which gets the weather data and logs the time taken. \n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\npublic\n \nclass\n \nWeatherForecast\n\n\n{\n\n    \nprivate\n \nLogger\n \nlogger\n \n=\n \nnew\n \nLogger\n();\n\n\n    \npublic\n \nvoid\n \nGetWeather\n()\n\n    \n{\n\n        \nStopwatch\n \nsw\n \n=\n \nnew\n \nStopwatch\n();\n\n        \nsw\n.\nStart\n();\n\n        \n// Get weather info from web service ...\n\n        \nsw\n.\nStop\n();\n\n        \nlogger\n.\nLog\n(\n$\n\"Webservice time = {sw.Elapsed}\"\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nYour \nWeatherForecast\n object now \ndepends\n on the \nLogger\n class. The \nLogger\n class is hard-coded into your program. We say that there is 'tight coupling' between the \nWeatherForecast\n and the \nLogger\n classes.\n\n\nNow this is all well and good for a small app that is not going to change, but has several drawbacks.\n\n\n\n\nIt is not easy to test \nWeatherForecast\n without having to open up the log file to see what was actually written to it.\n\n\nIt is not easy to change the logger if we decide that instead of logging to a file we want to log to a database instead.\n\n\n\n\nIt would be nice if we could just write \nWeatherForecast\n so that it could use any logger object that we decided to give it. The we could use a test logger for testing, another for logging to file, and another for writing the messages to a database, and so on. It would be really nice if, when we wrote \nWeatherForecast\n, we didn't need to know anything about the logger that would ultimately be used other than all we had to do was pass it a message.\n\n\nThe problem, of course, is the line\n\n\nprivate Logger logger = new Logger();\n\n\nTo write this line of code we hard code a reference to the \nLogger\n class, and once we have written it we can't change the logger without changing the \nWeatherForecast\n source code. Instead of hard-coding the dependancy, we would like to be able to pass the dependency in to \nWeatherForecast\n when we run our code.\n\n\nInterfaces\n\u00b6\n\n\n\n\nAn \nInterface\n defines the signatures of methods, properties, events or indexers of a class. A class or struct that implements the interface must implement the members of the interface that are specified in the interface definition.\n\n\n\n\nAn interface defines what a class will look like 'from the outside'. If a class implements a particular interface, you know that it will have the exact methods and properties etc. that are defined in the interface, with those exact parameters and types and return values. What goes on inside the class is none or your concern - what is important is that you know the interface and so you can use it in your program.\n\n\nSeveral different implementations of the interface might perform the task in completely different ways. For example, we could have one implementations of a logger interface which logs to file and another which logs to a database, but because they look exactly the same from the outside they can be used interchangeably in your program.\n\n\nFirst we need to define an interface that describes the essential public methods of our logger.\n\n\n1\n2\n3\n4\npublic\n \ninterface\n \nILogger\n\n\n{\n\n    \nvoid\n \nLog\n(\nstring\n \nmessage\n);\n\n\n}\n\n\n\n\n\n\n\nThis interface dictates that anything that impements it must provide a \nLog\n method which takes a string as a parameter and returns a void.\n\n\nNow we can write a logger class which implements this interface.\n\n\n1\n2\n3\n4\n5\n6\n7\npublic\n \nclass\n \nFileLogger\n \n:\n \nILogger\n\n\n{\n\n    \npublic\n \nvoid\n \nLog\n(\nstring\n \nmessage\n)\n\n    \n{\n\n        \n// code to write message to file\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nConstructor Injection\n\u00b6\n\n\nOne simple form of dependency injection is 'Constructor Injection'. We pass the dependency that we want the class to use into to class through its constructor at the time we instantiate an instance of the class.\n\n\nHere is a modified version of our class which takes a logger object in its constructor, keeps a reference to it in a private variable, and uses that logger when it needs to log something.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\npublic\n \nclass\n \nWeatherForecast\n\n\n{\n\n    \nprivate\n \nILogger\n \nlogger\n;\n\n\n    \npublic\n \nWeatherForecast\n(\nILogger\n \nspecific_Logger_to_Use\n)\n\n    \n{\n\n        \nlogger\n \n=\n \nspecific_Logger_to_Use\n;\n\n    \n}\n\n\n    \npublic\n \nvoid\n \nGetWeather\n()\n\n    \n{\n\n        \nStopwatch\n \nsw\n \n=\n \nnew\n \nStopwatch\n();\n\n        \nsw\n.\nStart\n();\n\n        \n// Get weather info from web service ...\n\n        \nThread\n.\nSleep\n(\n1000\n);\n\n        \nsw\n.\nStop\n();\n\n        \nlogger\n.\nLog\n(\n$\n\"Webservice time = {sw.Elapsed}\"\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nNote in line 3 that our private variable is of type \nILogger\n. We don't need to know which specific type of logger we are eventually going to get, just so long as it implements \nILogger\n.\n\n\nWhen we instantiate our class we can pass it a file logger, an email logger, or any other logger that implements the \nILogger\n interface. We can even make a mock logger that we can use during testing.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\nclass\n \nProgram\n\n\n{\n\n    \nstatic\n \nvoid\n \nMain\n(\nstring\n[]\n \nargs\n)\n\n    \n{\n\n        \n// this time we are going to use a FileLogger\n\n        \nFileLogger\n \nfileLogger\n \n=\n \nnew\n \nFileLogger\n();\n\n\n        \n// create a new instance of WeatherForecast and pass it the FileLogger to use\n\n        \nWeatherForecast\n \nforecast\n \n=\n \nnew\n \nWeatherForecast\n(\nfileLogger\n);\n\n\n        \nforecast\n.\nGetWeather\n();\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nNow \nWeatherForecast\n does not have to know which specific logger it is going to use - it only cares that when we come to use it we pass it a logger object that implements the \nILogger\n interface. In this program we are giving it a \nFileLogger\n, but in another program we might give it a \nDatabaseLogger\n and we wouldn't have to change \nWeatherForecast\n at all.\n\n\nThis is good because we can write \nWeatherForecast\n, test it, and tuck it away in a library somewhere and never have to touch it again. We can use it in lots of places, and each time we use it we can decide at the time which logger we want \nWeatherForecast\n to use.\n\n\nWe have 'injected' the dependency into \nWeatherForecast\n at the time we instantiated it.\n\n\nInversion of Control\n\u00b6\n\n\nIoC (\nInversion of Control\n) is a general programming principle where the flow of control through the program (which would normally have been under 'your' control) is 'inverted' so it is now under the control of a framework.\n\n\nFor example, in traditional text based programming (such as a batch file or a console program) you might write something to get the users name and greet them.\n\n\n1\n2\n3\n4\n5\n6\nstatic\n \nvoid\n \nMain\n(\nstring\n[]\n \nargs\n)\n\n\n{\n\n    \nConsole\n.\nWrite\n(\n\"Enter your name: \"\n);\n\n    \nstring\n \nname\n \n=\n \nConsole\n.\nReadLine\n();\n\n    \nConsole\n.\nWriteLine\n(\n$\n\"Welcome, {name}\"\n);\n\n\n}\n\n\n\n\n\n\n\nThe flow of the program is enitely under your control. You decide when to output to the console, and you decide when to read input from the console. It is your code that is running, and you make calls into other code (such as \nConsole.WriteLine\n) when you need to.\n\n\nHowever, if you are using some kind of framework (Windows forms, ASP.NET, Android, etc.) you might have a form with a text entry box labelled 'Enter your name', a button labelled 'Next', and an empty label called response. Your code would look something like\n\n\n1\n2\n3\n4\nprivate\n \nvoid\n \nNextButton_Click\n(\nobject\n \nsender\n,\n \nRoutedEventArgs\n \ne\n)\n\n\n{\n\n    \nResponse\n.\nText\n \n=\n \n$\n\"Welcome, {NameEntry.Text}\"\n;\n\n\n}\n\n\n\n\n\n\n\nNow it is \nnot\n your code that is in control - the \nframework\n is in control. When the user runs the application, it is the framework code that is running, and when the user hits the 'Next' button the framework makes a call into your code through the event handler mechanism.\n\n\nYou have handed control off to the framework and told it, \"Call me when you need me to do something.\" This is also known as the \nHollywood Principle\n - \"Don't call us. We'll call you!\"\n\n\nThere are many forms that this inversion of control can take, but an important factor in all of them is that the framework code is already written and you don't want to be messing with it. Somehow you need to be able to get the framework to call your code when the framework designer, at the time the framework was written, had no idea that your code even existed (in fact, it probably didn't).\n\n\nRegistering for events is one programming pattern which can achieve this. In the code above we have (elsewhere) told the framework which method to call when the button gets pushed. (Often this hookup is done behind the scenes by the graphical designer you use to create your form). When the button is pushed, the framework calls the \nNextButton_Click\n method to execute \nour\n code. The only stipulation is that the \nNextButton_Click\n method conforms to what the framework expects by way of parameters and return type for an event handler.\n\n\nDependency Injection is just another method of Inversion of Control, where your code (say, the logger) gets called by some other code (maybe the framework, maybe some other bit of your code) that itself knows nothing about your logger. All you need to do is follow the rules (ie. implement the \nILogger\n interface) and you can get the other code to call your code whenever it needs to.\n\n\nIoC Containers\n\u00b6\n\n\nWe could just stop there, because with Dependency Injection we have all we need to 'decouple' (ie. make independent) parts of our code. We can write a \nGetWeather\n class which uses a logger, and we don't care which logger is used when we write the \nGetWeather\n class (as long as it implements \nILogger\n). And we can write lots of other classes that use loggers, and write lots of different loggers, and mix and match to our heart's content. And many applications do just use manual Dependency Injection like this, where in the final application the desired logger service is supplied to each particular consumer class.\n\n\nHowever, we can go another step in automating this process by using what is called an IoC Container.\n\n\nThe code behind an IoC Container (sometimes also called a DI Container) can get a little complex and we are not going to delve into it at all in this article. There are \nmany ready-made IoC Containers\n available, and ASP.NET Core includes a simple one as part of the framework which is used so that \nyou\n can tell the \nframework\n what you want it to use as (for example) a logger. You can pick one of the many existing classes or make your own. You can also use the IoC Container to handle dependency injection for your own code.\n\n\nWhat Problem are we Solving?\n\u00b6\n\n\nEarlier we used this code to instatiate a logger of our choice and pass it to \nWeatherForecast\n\n\n1\n2\n3\n4\n5\n// this time we are going to use a FileLogger\n\n\nFileLogger\n \nfileLogger\n \n=\n \nnew\n \nFileLogger\n();\n\n\n\n// create a new instance of WeatherForecast and pass it the FileLogger to use\n\n\nWeatherForecast\n \nforecast\n \n=\n \nnew\n \nWeatherForecast\n(\nfileLogger\n);\n\n\n\n\n\n\n\nThere are two possible problems with this.\n\n\n\n\nWe might use this bit of code (or a bit very similar) in many places. If we wanted to change loggers to use the database logger instead we would have a lot of places to go and change our code.\n\n\nThe above example is very simple because although the \nWeatherForecast\n class has a dependency on a logger, the logger does not have a dependency on anything else. This is often not the case. Maybe our database logger needs a database object in it's constructor (and there may be several different types of database we could pass it), and each database object needs a connection string passed into it's constructor. Quite soon we end up with a complex 'dependency graph' - a large tree of objects depending on objects depending on objects.\n\n\n\n\nIn the code above, the line\n\n\n1\nWeatherForecast\n \nforecast\n \n=\n \nnew\n \nWeatherForecast\n(\nfileLogger\n);\n\n\n\n\n\n\n\nis where we instantiate our \nWeatherForecast\n object. The logger we are using is hard coded into this line which is inflexible and hard to maintain, especially where either of the above two points apply.\n\n\nThe Solution\n\u00b6\n\n\nAn IoC Container is a 'factory' which instantiates instances of classes for us, and in doing so also instantiates instances of all the dependencies that those classes need and injects them through the constructors. There are various different ways that such containers can be implemented, but the following is typical.\n\n\nFirst we create an instance of a container, and then we 'register' all the dependencies with it.\n\n\n1\n2\n3\nIOContainer\n \niocContainer\n \n=\n \nnew\n \nIOCContainer\n();\n\n\n\niocContainer\n.\nAddService\n<\nILogger\n,\n \nFileLogger\n>();\n\n\n\n\n\n\n\nThis code registers the concrete type \nFileLogger\n and tell the container to use a \nFileLogger\n wherever it needs a concrete implementation of \nILogger\n.\n\n\nThen we can use the container to create an instance of our \nWeatherForecast\n class as follows.\n\n\n1\nWeatherForcast\n \nforecast\n \n=\n \niocContainer\n.\nResolve\n<\nWeatherForecast\n>();\n\n\n\n\n\n\n\nThe container looks at the \nWeatherForecast\n class we have asked for and sees that in its constructor it needs an instance of an \nILogger\n. It looks at what has been registered and sees that for an \nILogger\n it needs to create an instance of the \nFileLogger\n class, which it does. It can now create an instance of the \nWeatherForecast\n class, passing the \nFileLogger\n to its constructor.\n\n\nWhen we want to change the logger, we only have to change it in the one place where we regisered it with the container, which is normally done right at the beginning of the program before anything else.\n\n\nAlso, if there is a deep tree of nested dependencies (which is quite normal in many programs) the container will create instances of all the dependencies that are needed - all we need to do is register them.\n\n\nImplementation in ASP.Net Core\n\u00b6",
            "title": "Programming concepts"
        },
        {
            "location": "/programming-concepts/#programming-concepts",
            "text": "",
            "title": "Programming Concepts"
        },
        {
            "location": "/programming-concepts/#dependency-injection-inversion-of-control",
            "text": "Introduction to Dependency Injection in ASP.NET Core  - Microsoft page",
            "title": "Dependency Injection / Inversion of Control"
        },
        {
            "location": "/programming-concepts/#what-and-why",
            "text": "A  dependency  is another class that the code you are writing depends on.   Say you are writing an app and you want to log certain performance information - maybe you get current weather data from a web service and you want to log how long each request takes. You write a class to do that logging and call it  Logger  with a  Log(string message)  method which writes your message to a file.  1\n2\n3\n4\n5\n6\n7 public   class   Logger  { \n     public   void   Log ( string   message ) \n     { \n         // write message to log file \n     }  }    Here is the class which gets the weather data and logs the time taken.    1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13 public   class   WeatherForecast  { \n     private   Logger   logger   =   new   Logger (); \n\n     public   void   GetWeather () \n     { \n         Stopwatch   sw   =   new   Stopwatch (); \n         sw . Start (); \n         // Get weather info from web service ... \n         sw . Stop (); \n         logger . Log ( $ \"Webservice time = {sw.Elapsed}\" ); \n     }  }    Your  WeatherForecast  object now  depends  on the  Logger  class. The  Logger  class is hard-coded into your program. We say that there is 'tight coupling' between the  WeatherForecast  and the  Logger  classes.  Now this is all well and good for a small app that is not going to change, but has several drawbacks.   It is not easy to test  WeatherForecast  without having to open up the log file to see what was actually written to it.  It is not easy to change the logger if we decide that instead of logging to a file we want to log to a database instead.   It would be nice if we could just write  WeatherForecast  so that it could use any logger object that we decided to give it. The we could use a test logger for testing, another for logging to file, and another for writing the messages to a database, and so on. It would be really nice if, when we wrote  WeatherForecast , we didn't need to know anything about the logger that would ultimately be used other than all we had to do was pass it a message.  The problem, of course, is the line  private Logger logger = new Logger();  To write this line of code we hard code a reference to the  Logger  class, and once we have written it we can't change the logger without changing the  WeatherForecast  source code. Instead of hard-coding the dependancy, we would like to be able to pass the dependency in to  WeatherForecast  when we run our code.",
            "title": "What and Why?"
        },
        {
            "location": "/programming-concepts/#interfaces",
            "text": "An  Interface  defines the signatures of methods, properties, events or indexers of a class. A class or struct that implements the interface must implement the members of the interface that are specified in the interface definition.   An interface defines what a class will look like 'from the outside'. If a class implements a particular interface, you know that it will have the exact methods and properties etc. that are defined in the interface, with those exact parameters and types and return values. What goes on inside the class is none or your concern - what is important is that you know the interface and so you can use it in your program.  Several different implementations of the interface might perform the task in completely different ways. For example, we could have one implementations of a logger interface which logs to file and another which logs to a database, but because they look exactly the same from the outside they can be used interchangeably in your program.  First we need to define an interface that describes the essential public methods of our logger.  1\n2\n3\n4 public   interface   ILogger  { \n     void   Log ( string   message );  }    This interface dictates that anything that impements it must provide a  Log  method which takes a string as a parameter and returns a void.  Now we can write a logger class which implements this interface.  1\n2\n3\n4\n5\n6\n7 public   class   FileLogger   :   ILogger  { \n     public   void   Log ( string   message ) \n     { \n         // code to write message to file \n     }  }",
            "title": "Interfaces"
        },
        {
            "location": "/programming-concepts/#constructor-injection",
            "text": "One simple form of dependency injection is 'Constructor Injection'. We pass the dependency that we want the class to use into to class through its constructor at the time we instantiate an instance of the class.  Here is a modified version of our class which takes a logger object in its constructor, keeps a reference to it in a private variable, and uses that logger when it needs to log something.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19 public   class   WeatherForecast  { \n     private   ILogger   logger ; \n\n     public   WeatherForecast ( ILogger   specific_Logger_to_Use ) \n     { \n         logger   =   specific_Logger_to_Use ; \n     } \n\n     public   void   GetWeather () \n     { \n         Stopwatch   sw   =   new   Stopwatch (); \n         sw . Start (); \n         // Get weather info from web service ... \n         Thread . Sleep ( 1000 ); \n         sw . Stop (); \n         logger . Log ( $ \"Webservice time = {sw.Elapsed}\" ); \n     }  }    Note in line 3 that our private variable is of type  ILogger . We don't need to know which specific type of logger we are eventually going to get, just so long as it implements  ILogger .  When we instantiate our class we can pass it a file logger, an email logger, or any other logger that implements the  ILogger  interface. We can even make a mock logger that we can use during testing.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13 class   Program  { \n     static   void   Main ( string []   args ) \n     { \n         // this time we are going to use a FileLogger \n         FileLogger   fileLogger   =   new   FileLogger (); \n\n         // create a new instance of WeatherForecast and pass it the FileLogger to use \n         WeatherForecast   forecast   =   new   WeatherForecast ( fileLogger ); \n\n         forecast . GetWeather (); \n     }  }    Now  WeatherForecast  does not have to know which specific logger it is going to use - it only cares that when we come to use it we pass it a logger object that implements the  ILogger  interface. In this program we are giving it a  FileLogger , but in another program we might give it a  DatabaseLogger  and we wouldn't have to change  WeatherForecast  at all.  This is good because we can write  WeatherForecast , test it, and tuck it away in a library somewhere and never have to touch it again. We can use it in lots of places, and each time we use it we can decide at the time which logger we want  WeatherForecast  to use.  We have 'injected' the dependency into  WeatherForecast  at the time we instantiated it.",
            "title": "Constructor Injection"
        },
        {
            "location": "/programming-concepts/#inversion-of-control",
            "text": "IoC ( Inversion of Control ) is a general programming principle where the flow of control through the program (which would normally have been under 'your' control) is 'inverted' so it is now under the control of a framework.  For example, in traditional text based programming (such as a batch file or a console program) you might write something to get the users name and greet them.  1\n2\n3\n4\n5\n6 static   void   Main ( string []   args )  { \n     Console . Write ( \"Enter your name: \" ); \n     string   name   =   Console . ReadLine (); \n     Console . WriteLine ( $ \"Welcome, {name}\" );  }    The flow of the program is enitely under your control. You decide when to output to the console, and you decide when to read input from the console. It is your code that is running, and you make calls into other code (such as  Console.WriteLine ) when you need to.  However, if you are using some kind of framework (Windows forms, ASP.NET, Android, etc.) you might have a form with a text entry box labelled 'Enter your name', a button labelled 'Next', and an empty label called response. Your code would look something like  1\n2\n3\n4 private   void   NextButton_Click ( object   sender ,   RoutedEventArgs   e )  { \n     Response . Text   =   $ \"Welcome, {NameEntry.Text}\" ;  }    Now it is  not  your code that is in control - the  framework  is in control. When the user runs the application, it is the framework code that is running, and when the user hits the 'Next' button the framework makes a call into your code through the event handler mechanism.  You have handed control off to the framework and told it, \"Call me when you need me to do something.\" This is also known as the  Hollywood Principle  - \"Don't call us. We'll call you!\"  There are many forms that this inversion of control can take, but an important factor in all of them is that the framework code is already written and you don't want to be messing with it. Somehow you need to be able to get the framework to call your code when the framework designer, at the time the framework was written, had no idea that your code even existed (in fact, it probably didn't).  Registering for events is one programming pattern which can achieve this. In the code above we have (elsewhere) told the framework which method to call when the button gets pushed. (Often this hookup is done behind the scenes by the graphical designer you use to create your form). When the button is pushed, the framework calls the  NextButton_Click  method to execute  our  code. The only stipulation is that the  NextButton_Click  method conforms to what the framework expects by way of parameters and return type for an event handler.  Dependency Injection is just another method of Inversion of Control, where your code (say, the logger) gets called by some other code (maybe the framework, maybe some other bit of your code) that itself knows nothing about your logger. All you need to do is follow the rules (ie. implement the  ILogger  interface) and you can get the other code to call your code whenever it needs to.",
            "title": "Inversion of Control"
        },
        {
            "location": "/programming-concepts/#ioc-containers",
            "text": "We could just stop there, because with Dependency Injection we have all we need to 'decouple' (ie. make independent) parts of our code. We can write a  GetWeather  class which uses a logger, and we don't care which logger is used when we write the  GetWeather  class (as long as it implements  ILogger ). And we can write lots of other classes that use loggers, and write lots of different loggers, and mix and match to our heart's content. And many applications do just use manual Dependency Injection like this, where in the final application the desired logger service is supplied to each particular consumer class.  However, we can go another step in automating this process by using what is called an IoC Container.  The code behind an IoC Container (sometimes also called a DI Container) can get a little complex and we are not going to delve into it at all in this article. There are  many ready-made IoC Containers  available, and ASP.NET Core includes a simple one as part of the framework which is used so that  you  can tell the  framework  what you want it to use as (for example) a logger. You can pick one of the many existing classes or make your own. You can also use the IoC Container to handle dependency injection for your own code.",
            "title": "IoC Containers"
        },
        {
            "location": "/programming-concepts/#what-problem-are-we-solving",
            "text": "Earlier we used this code to instatiate a logger of our choice and pass it to  WeatherForecast  1\n2\n3\n4\n5 // this time we are going to use a FileLogger  FileLogger   fileLogger   =   new   FileLogger ();  // create a new instance of WeatherForecast and pass it the FileLogger to use  WeatherForecast   forecast   =   new   WeatherForecast ( fileLogger );    There are two possible problems with this.   We might use this bit of code (or a bit very similar) in many places. If we wanted to change loggers to use the database logger instead we would have a lot of places to go and change our code.  The above example is very simple because although the  WeatherForecast  class has a dependency on a logger, the logger does not have a dependency on anything else. This is often not the case. Maybe our database logger needs a database object in it's constructor (and there may be several different types of database we could pass it), and each database object needs a connection string passed into it's constructor. Quite soon we end up with a complex 'dependency graph' - a large tree of objects depending on objects depending on objects.   In the code above, the line  1 WeatherForecast   forecast   =   new   WeatherForecast ( fileLogger );    is where we instantiate our  WeatherForecast  object. The logger we are using is hard coded into this line which is inflexible and hard to maintain, especially where either of the above two points apply.",
            "title": "What Problem are we Solving?"
        },
        {
            "location": "/programming-concepts/#the-solution",
            "text": "An IoC Container is a 'factory' which instantiates instances of classes for us, and in doing so also instantiates instances of all the dependencies that those classes need and injects them through the constructors. There are various different ways that such containers can be implemented, but the following is typical.  First we create an instance of a container, and then we 'register' all the dependencies with it.  1\n2\n3 IOContainer   iocContainer   =   new   IOCContainer ();  iocContainer . AddService < ILogger ,   FileLogger >();    This code registers the concrete type  FileLogger  and tell the container to use a  FileLogger  wherever it needs a concrete implementation of  ILogger .  Then we can use the container to create an instance of our  WeatherForecast  class as follows.  1 WeatherForcast   forecast   =   iocContainer . Resolve < WeatherForecast >();    The container looks at the  WeatherForecast  class we have asked for and sees that in its constructor it needs an instance of an  ILogger . It looks at what has been registered and sees that for an  ILogger  it needs to create an instance of the  FileLogger  class, which it does. It can now create an instance of the  WeatherForecast  class, passing the  FileLogger  to its constructor.  When we want to change the logger, we only have to change it in the one place where we regisered it with the container, which is normally done right at the beginning of the program before anything else.  Also, if there is a deep tree of nested dependencies (which is quite normal in many programs) the container will create instances of all the dependencies that are needed - all we need to do is register them.",
            "title": "The Solution"
        },
        {
            "location": "/programming-concepts/#implementation-in-aspnet-core",
            "text": "",
            "title": "Implementation in ASP.Net Core"
        }
    ]
}